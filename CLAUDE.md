# 💡 CLAUDE DEVELOPMENT BEST PRACTICES

This document unifies the standard planning and implementation workflow with rigorous code, testing, and Git conventions. It is designed to ensure **maintainability, correctness, and velocity** while keeping all changes **simple, minimal, and consistent with the existing codebase**.

---

## 🔁 STANDARD WORKFLOW

### 1. THINK FIRST — PLAN, THEN CODE

- 📖 **Understand the Problem**
  - Carefully review the prompt and relevant codebase sections before proposing changes.
  - Identify scope, dependencies, and risks before touching code.

- 📄 **Draft the Plan**
  - Create or update `tasks/todo.md` with a precise plan.
    - ✅ Checklist of **atomic** tasks with intended outcomes.
    - 🚧 Tasks should be **minimal in scope**, avoid cascading changes.
    - 🧠 Add a `## Review` section to summarize what was done later.

- 🧾 **Get Confirmation**
  - Always check in with the user before starting. Use `qplan` to validate consistency and simplicity of approach.

---

### 2. WHILE CODING — KEEP IT SIMPLE

- ✏️ Each task should touch **as little code as possible**.
- 🪶 Avoid refactoring unless:
  - The function is reused elsewhere.
  - It enables proper unit testing.
  - The code is unreadable without it.
- 💡 Add high-level explanations after each change—focus on **what changed and why**, not low-level diffs.

---

### 3. AFTER CODING — REVIEW & EXPLAIN

- 📦 Update `tasks/todo.md → ## Review` with:
  - Summary of changes.
  - Any tradeoffs, limitations, or remaining edge cases.
- ✅ Ensure tests pass.
- 🧪 Validate types, formatting, and linting.
- 📤 Push your code using `qgit` instructions.

---

## 🧠 CLAUDE CODING BEST PRACTICES

---

### 🧱 1. BEFORE CODING

- **BP-1 (MUST)** Ask clarifying questions if anything is ambiguous.
- **BP-2 (SHOULD)** Draft and confirm approach for complex work.
- **BP-3 (SHOULD)** If multiple approaches exist, provide a **clear, objective pros/cons comparison**.

---

### 🛠️ 2. WHILE CODING

#### ✅ CODE STYLE & ORGANIZATION

- **C-1 (MUST)** Follow TDD: write failing test → implement → pass.
- **C-2 (MUST)** Use **domain-consistent naming** for functions/types.
- **C-3 (SHOULD NOT)** Use classes unless absolutely necessary.
- **C-4 (SHOULD)** Favor small, **composable**, and **testable** functions.
- **C-5 (MUST)** Use branded types for identifiers:
  ```ts
  type ProductId = Brand<string, 'ProductId'> // ✅
  type ProductId = string                    // ❌
  ```
- **C-6 (MUST)** Use `import type { … }` for type-only imports.
- **C-7 (SHOULD NOT)** Add comments unless essential for understanding or safety.
- **C-8 (SHOULD)** Default to `type` over `interface`, unless merging or readability dictates otherwise.
- **C-9 (SHOULD NOT)** Extract functions unless:
  - Reused.
  - Needed for isolated testing.
  - Dramatically improves clarity.

---

### 🧪 3. TESTING

- **T-1 (MUST)** Place simple unit tests in colocated `*.spec.ts`.
- **T-2 (MUST)** For APIs, write integration tests in `packages/api/test/*.spec.ts`.
- **T-3 (MUST)** Separate unit vs integration tests (esp. DB interaction).
- **T-4 (SHOULD)** Prefer real integration tests over mocks.
- **T-5 (SHOULD)** Unit-test edge cases and complex logic.
- **T-6 (SHOULD)** Assert full structures rather than step-by-step checks:
  ```ts
  expect(result).toEqual([{ id: 1, name: 'X' }]); // ✅
  ```
- **T-7 (SHOULD)** Parameterize tests and avoid hard-coded literals.
- **T-8 (SHOULD)** Describe **exact behavior** in test names.
- **T-9 (SHOULD)** Compare results to independent truths, not expected outputs derived from the same function.
- **T-10 (SHOULD)** Express **axioms/invariants** when applicable (use `fast-check` for property tests).
- **T-11 (MUST)** Use strong assertions:
  ```ts
  expect(x).toBe(42);   // ✅
  expect(x).toBeGreaterThan(40); // ❌
  ```

---

### 🛢️ 4. DATABASE

- **D-1 (MUST)** Use type `KyselyDatabase | Transaction<Database>` for helpers.
- **D-2 (SHOULD)** Override wrong autogenerated DB types in `db-types.override.ts`.

---

### 📦 5. CODE ORGANIZATION

- `packages/api`: Fastify backend
- `packages/web`: Next.js frontend
- `packages/shared`: Shared code (only if used by ≥ 2 packages)
- `packages/api-schema`: Schemas via TypeBox
- Use `packages/shared/social.ts` for social media character/media limits

---

### 🔧 6. TOOLING GATES

- **G-1 (MUST)** Pass `prettier --check`
- **G-2 (MUST)** Pass `turbo typecheck lint`

---

### 🧾 7. GIT & COMMITS

- **GH-1 (MUST)** Use [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0):
  ```
  feat(api): add endpoint to publish post
  fix(social): correct char count check
  ```
- **GH-2 (SHOULD NOT)** Mention Claude or Anthropic in commit messages.
- Include:
  - `type(scope): description`
  - Optional body and footers
  - Use `BREAKING CHANGE:` if applicable

---

## 🧠 FUNCTION QUALITY CHECKLIST

Before finalizing any function, ask:

1. Is it easy to understand? If yes, stop here.
2. Does it have high cyclomatic complexity? Refactor.
3. Can data structures (tree, queue, parser, etc.) make it clearer?
4. Any unused parameters?
5. Can type casting be done at input instead?
6. Is it testable without mocking infra (DB, Redis)? If not, can it be integration-tested?
7. Any implicit logic that should be arguments?
8. Can the name be improved? Try 3 alternatives and pick the best.

🚫 **DON’T refactor into a new function unless**:
- It’s reused,
- Makes testing possible,
- Or simplifies unreadable code.

---

## ✅ TEST QUALITY CHECKLIST

1. Parameterize inputs; avoid unexplained literals.
2. No trivial tests (e.g. `expect(2).toBe(2)`).
3. Test descriptions must match what is asserted.
4. Don’t reuse output as expected input.
5. Follow same lint/type/style as prod code.
6. Use invariants when possible (e.g. idempotence, round-trip).
7. Use `expect.any(...)` for wildcard values (e.g., random IDs).
8. Use strong, tight assertions.
9. Test realistic, edge, invalid, and boundary inputs.
10. Don’t test what TypeScript already enforces.

---

## ⏩ SHORTCUT COMMANDS

- **qnew** → Assume and follow all best practices from this doc (`CLAUDE.md`)
- **qplan** → Validate plan is consistent, minimal, and well-reasoned
- **qcode** → Implement, test, and format your code
- **qcheck** → Full review of all major changes (functions + tests)
- **qcheckf** → Review of major functions only
- **qcheckt** → Review of major tests only
- **qux** → UX walkthrough scenarios
- **qgit** → Stage, commit, and push using conventional format